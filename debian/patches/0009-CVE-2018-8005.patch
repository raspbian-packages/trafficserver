Description: Patch for CVE-2018-8005
 When the there are multiple ranges in a range request ATS will read the
 entire object from cache.  This can cause performance problems with large
 objects in cache.
Author: Bryan Call <bcall@apache.org>
Origin: upstream, https://github.com/apache/trafficserver/pull/3106
        upstream, https://github.com/apache/trafficserver/pull/3124
Applied-Upstream: https://github.com/apache/trafficserver/commit/bbcbb7cf7f25ebfe3a97d792e889de618e41a6a4
Reviewed-by: Jean Baptiste Favre <debian@jbfavre.org>
Last-Update: 2018-08-29
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/doc/admin-guide/files/records.config.en.rst
+++ b/doc/admin-guide/files/records.config.en.rst
@@ -1624,6 +1624,22 @@ Security
    post body larger than this limit the response will be terminated with
    413 - Request Entity Too Large and logged accordingly.
 
+.. ts:cv:: CONFIG proxy.config.http.allow_multi_range INT 1
+   :reloadable:
+   :overridable:
+
+   This option allows the administrator to configure different behavior and
+   handling of requests with multiple ranges in the ``Range`` header.
+
+   ===== ======================================================================
+   Value Description
+   ===== ======================================================================
+   ``0`` Do not allow multiple ranges, effectively ignoring the ``Range`` header
+   ``1`` Allows multiple ranges. This can be potentially dangerous since well
+         formed requests can cause excessive resource consumption on the server.
+   ``2`` Similar to 0, except return a 416 error code and no response body.
+   ===== ======================================================================
+
 Cache Control
 =============
 
--- a/mgmt/RecordsConfig.cc
+++ b/mgmt/RecordsConfig.cc
@@ -602,6 +602,8 @@ static const RecordElement RecordsConfig
   ,
   {RECT_CONFIG, "proxy.config.http.enable_http_stats", RECD_INT, "1", RECU_DYNAMIC, RR_NULL, RECC_INT, "[0-1]", RECA_NULL}
   ,
+  {RECT_CONFIG, "proxy.config.http.allow_multi_range", RECD_INT, "1", RECU_DYNAMIC, RR_NULL, RECC_INT, "[0-2]", RECA_NULL}
+  ,
   {RECT_CONFIG, "proxy.config.http.normalize_ae_gzip", RECD_INT, "1", RECU_DYNAMIC, RR_NULL, RECC_INT, "[0-1]", RECA_NULL}
   ,
 
--- a/proxy/InkAPI.cc
+++ b/proxy/InkAPI.cc
@@ -8077,6 +8077,9 @@ _conf_to_memberp(TSOverridableConfigKey
     typ = OVERRIDABLE_TYPE_INT;
     ret = &overridableHttpConfig->srv_enabled;
     break;
+  case TS_CONFIG_HTTP_ALLOW_MULTI_RANGE:
+    ret = &overridableHttpConfig->allow_multi_range;
+    break;
   // This helps avoiding compiler warnings, yet detect unhandled enum members.
   case TS_CONFIG_NULL:
   case TS_CONFIG_LAST_ENTRY:
@@ -8333,6 +8336,8 @@ TSHttpTxnConfigFind(const char *name, in
     case 'e':
       if (!strncmp(name, "proxy.config.http.cache.range.write", length)) {
         cnf = TS_CONFIG_HTTP_CACHE_RANGE_WRITE;
+      } else if (!strncmp(name, "proxy.config.http.allow_multi_range", length)) {
+        cnf = TS_CONFIG_HTTP_ALLOW_MULTI_RANGE;
       }
       break;
     case 'p':
--- a/proxy/http/HttpConfig.cc
+++ b/proxy/http/HttpConfig.cc
@@ -1065,6 +1065,7 @@ HttpConfig::startup()
   HttpEstablishStaticConfigByte(c.record_cop_page, "proxy.config.http.record_heartbeat");
 
   HttpEstablishStaticConfigByte(c.oride.send_http11_requests, "proxy.config.http.send_http11_requests");
+  HttpEstablishStaticConfigByte(c.oride.allow_multi_range, "proxy.config.http.allow_multi_range");
 
   // HTTP Referer Filtering
   HttpEstablishStaticConfigByte(c.referer_filter_enabled, "proxy.config.http.referer_filter");
@@ -1315,6 +1316,7 @@ HttpConfig::reconfigure()
   params->oride.cache_required_headers = m_master.oride.cache_required_headers;
   params->oride.cache_range_lookup     = INT_TO_BOOL(m_master.oride.cache_range_lookup);
   params->oride.cache_range_write      = INT_TO_BOOL(m_master.oride.cache_range_write);
+  params->oride.allow_multi_range      = m_master.oride.allow_multi_range;
 
   params->connect_ports_string = ats_strdup(m_master.connect_ports_string);
   params->connect_ports        = parse_ports_list(params->connect_ports_string);
--- a/proxy/http/HttpConfig.h
+++ b/proxy/http/HttpConfig.h
@@ -398,6 +398,7 @@ struct OverridableHttpConfigParams {
       cache_required_headers(2),
       cache_range_lookup(1),
       cache_range_write(0),
+      allow_multi_range(1),
       insert_request_via_string(1),
       insert_response_via_string(0),
       doc_in_cache_skip_dns(1),
@@ -532,6 +533,7 @@ struct OverridableHttpConfigParams {
   MgmtByte cache_required_headers;
   MgmtByte cache_range_lookup;
   MgmtByte cache_range_write;
+  MgmtByte allow_multi_range;
 
   MgmtByte insert_request_via_string;
   MgmtByte insert_response_via_string;
--- a/doc/developer-guide/api/functions/TSHttpOverridableConfig.en.rst
+++ b/doc/developer-guide/api/functions/TSHttpOverridableConfig.en.rst
@@ -150,6 +150,7 @@ The following configurations (from ``rec
 |   :ts:cv:`proxy.config.http.number_of_redirections`
 |   :ts:cv:`proxy.config.http.cache.max_open_write_retries`
 |   :ts:cv:`proxy.config.http.redirect_use_orig_cache_key`
+|   :ts:cv:`proxy.config.http.allow_multi_range`
 
 Examples
 ========
--- a/doc/developer-guide/api/types/TSOverridableConfigKey.en.rst
+++ b/doc/developer-guide/api/types/TSOverridableConfigKey.en.rst
@@ -205,6 +205,8 @@ Enumeration Members
 
 .. c:member:: TSOverridableConfigKey TS_CONFIG_LAST_ENTRY
 
+.. c:member:: TSOverridableConfigKey  TS_CONFIG_HTTP_ALLOW_MULTI_RANGE
+
 Description
 ===========
 
--- a/lib/ts/apidefs.h.in
+++ b/lib/ts/apidefs.h.in
@@ -741,6 +741,7 @@ typedef enum {
   TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS,
   TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN,
   TS_CONFIG_SRV_ENABLED,
+  TS_CONFIG_HTTP_ALLOW_MULTI_RANGE,
   TS_CONFIG_LAST_ENTRY
 } TSOverridableConfigKey;
 
--- a/plugins/experimental/ts_lua/ts_lua_http_config.c
+++ b/plugins/experimental/ts_lua/ts_lua_http_config.c
@@ -118,6 +118,7 @@ typedef enum {
   TS_LUA_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT       = TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT,
   TS_LUA_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS      = TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS,
   TS_LUA_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN            = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN,
+  TS_LUA_CONFIG_HTTP_ALLOW_MULTI_RANGE                        = TS_CONFIG_HTTP_ALLOW_MULTI_RANGE,
   TS_LUA_CONFIG_LAST_ENTRY                                    = TS_CONFIG_LAST_ENTRY,
   TS_LUA_CONFIG_SRV_ENABLED                                   = TS_CONFIG_SRV_ENABLED,
 } TSLuaOverridableConfigKey;
@@ -230,6 +231,7 @@ ts_lua_var_item ts_lua_http_config_vars[
   TS_LUA_MAKE_VAR_ITEM(TS_LUA_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS),
   TS_LUA_MAKE_VAR_ITEM(TS_LUA_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN),
   TS_LUA_MAKE_VAR_ITEM(TS_CONFIG_SRV_ENABLED),
+  TS_LUA_MAKE_VAR_ITEM(TS_LUA_CONFIG_HTTP_ALLOW_MULTI_RANGE),
   TS_LUA_MAKE_VAR_ITEM(TS_LUA_CONFIG_LAST_ENTRY),
 };
 
--- a/proxy/InkAPITest.cc
+++ b/proxy/InkAPITest.cc
@@ -7616,6 +7616,7 @@ const char *SDK_Overridable_Configs[TS_C
   "proxy.config.http.parent_proxy.total_connect_attempts",
   "proxy.config.http.transaction_active_timeout_in",
   "proxy.config.srv_enabled",
+  "proxy.config.http.allow_multi_range",
 };
 
 REGRESSION_TEST(SDK_API_OVERRIDABLE_CONFIGS)(RegressionTest *test, int /* atype ATS_UNUSED */, int *pstatus)
--- a/proxy/http/HttpSM.cc
+++ b/proxy/http/HttpSM.cc
@@ -4417,27 +4417,50 @@ HttpSM::do_range_setup_if_necessary()
   t_state.range_setup = HttpTransact::RANGE_NONE;
 
   if (t_state.method == HTTP_WKSIDX_GET && t_state.hdr_info.client_request.version_get() == HTTPVersion(1, 1)) {
-    do_range_parse(field);
-
     if (t_state.range_setup == HttpTransact::RANGE_REQUESTED) {
+      bool do_transform = false;
+
       if (!t_state.range_in_cache) {
         Debug("http_range", "range can't be satisfied from cache, force origin request");
         t_state.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS;
         return;
       }
 
-      // if only one range entry and pread is capable, no need transform range
-      if (t_state.num_range_fields == 1 && cache_sm.cache_read_vc->is_pread_capable()) {
-        t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;
-      } else if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == NULL) {
-        Debug("http_trans", "Unable to accelerate range request, fallback to transform");
-        content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,
-                                                                                 &field_content_type_len);
-        // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)
-        range_trans = transformProcessor.range_transform(mutex.get(), t_state.ranges, t_state.num_range_fields,
-                                                         &t_state.hdr_info.transform_response, content_type, field_content_type_len,
-                                                         t_state.cache_info.object_read->object_size_get());
-        api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);
+      if (t_state.num_range_fields > 1) {
+        if (0 == t_state.txn_conf->allow_multi_range) {
+          t_state.range_setup = HttpTransact::RANGE_NONE;                                 // No Range required (not allowed)
+          t_state.hdr_info.client_request.field_delete(MIME_FIELD_RANGE, MIME_LEN_RANGE); // ... and nuke the Range header too
+          t_state.num_range_fields = 0;
+        } else if (1 == t_state.txn_conf->allow_multi_range) {
+          do_transform = true;
+        } else {
+          t_state.num_range_fields = 0;
+          t_state.range_setup      = HttpTransact::RANGE_NOT_SATISFIABLE;
+        }
+      } else {
+        if (cache_sm.cache_read_vc->is_pread_capable()) {
+          // If only one range entry and pread is capable, no need transform range
+          t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;
+        } else {
+          do_transform = true;
+        }
+      }
+
+      // We have to do the transform on (allowed) multi-range request, *or* if the VC is not pread capable
+      if (do_transform) {
+        if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {
+          Debug("http_trans", "Unable to accelerate range request, fallback to transform");
+          content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,
+                                                                                   &field_content_type_len);
+          // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)
+          range_trans = transformProcessor.range_transform(
+            mutex.get(), t_state.ranges, t_state.num_range_fields, &t_state.hdr_info.transform_response, content_type,
+            field_content_type_len, t_state.cache_info.object_read->object_size_get());
+          api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);
+        } else {
+          // ToDo: Do we do something here? The theory is that multiple transforms do not behave well with
+          // the range transform needed here.
+        }
       }
     }
   }
